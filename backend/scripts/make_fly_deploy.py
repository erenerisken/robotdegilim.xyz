"""
Create a clean, self-contained Fly.io deployable folder for the backend.

Outputs by default to: <repo_root>/fly-io/robotdegilim

Generated contents:
- Dockerfile (Gunicorn, port 8080, entrypoint src.app:app)
- fly.toml (http_service on 8080)
- requirements.txt (copied from backend/requirements.txt)
- .dockerignore (sane defaults)
- src/ (copied from backend/src)

Usage (from repo root or any dir):
    python backend/scripts/make_fly_deploy.py --help

Notes:
- Configure secrets on Fly with: fly secrets set ACCESS_KEY=... SECRET_ACCESS_KEY=... MAIL_USERNAME=... MAIL_PASSWORD=...
- On first deploy you might want to run: fly apps create <app-name> (or `fly launch` in the folder)
"""

from __future__ import annotations

import argparse
import json
import os
import re
import shutil
import sys
from pathlib import Path


RECOMMENDED_PY_VERSION = "3.12"


DOCKERFILE_TEMPLATE = """# syntax=docker/dockerfile:1

ARG PYTHON_VERSION={python_version}

FROM python:${{PYTHON_VERSION}}-slim

LABEL fly_launch_runtime="flask"

WORKDIR /code

# Install system deps (optional minimal set). Uncomment if you need build tools for some wheels.
# RUN apt-get update && apt-get install -y --no-install-recommends \
#     build-essential \
#     && rm -rf /var/lib/apt/lists/*

COPY requirements.txt requirements.txt
RUN pip3 install --no-cache-dir -r requirements.txt

# Copy only the app sources
COPY src ./src

# Pre-create runtime folders (logs/data are created at runtime too, but ensures path exists)
RUN mkdir -p storage/logs storage/data

EXPOSE 8080

# Use src.app:app where `app` is the Flask app object in backend/src/app.py
CMD ["gunicorn", "-w", "{workers}", "-b", "[::]:8080", "--timeout", "{timeout}", "src.app:app"]
"""


FLY_TOML_TEMPLATE = """# fly.toml app configuration generated by make_fly_deploy.py

app = '{app_name}'
primary_region = '{region}'

[build]

[env]
    LOG_LEVEL = "INFO"
    LOG_JSON = "false"
    APP_VERSION = "0.1.0"
    ALLOWED_ORIGINS = "*"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'off'
  auto_start_machines = false
  min_machines_running = 1
  processes = ['app']

    # Optional HTTP health check for /status
    [[http_service.checks]]
        type = "http"
        interval = "10s"
        timeout = "2s"
        grace_period = "10s"
        method = "get"
        path = "/status"

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1
"""


DOCKERIGNORE = """# Created by make_fly_deploy.py
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.so
.pytest_cache/
.mypy_cache/
.venv/
venv/
.DS_Store
.git/
.gitignore
*.log
storage/logs/
# Ignore generated data completely; built artifacts are fetched at runtime
storage/data/
tests/
"""


def copy_requirements(backend_dir: Path, target_dir: Path) -> None:
    src_req = backend_dir / "requirements.txt"
    if not src_req.exists():
        raise FileNotFoundError(f"Missing requirements.txt at {src_req}")
    shutil.copy2(src_req, target_dir / "requirements.txt")


def copy_sources(backend_dir: Path, target_dir: Path) -> None:
    src_dir = backend_dir / "src"
    if not src_dir.exists():
        raise FileNotFoundError(f"Missing backend/src at {src_dir}")
    dst_dir = target_dir / "src"
    if dst_dir.exists():
        shutil.rmtree(dst_dir)
    shutil.copytree(src_dir, dst_dir)


def write_file(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8", newline="\n")


def read_file_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def patch_dockerfile(content: str, python_version: str, *, workers: int, timeout: int) -> str:
    """Patch a provided Dockerfile to be compatible with our folder layout.

    - Ensure gunicorn target is src.app:app (project code lives under src/)
    - Prefer EXPOSE 8080 (idempotent)
    - Ensure ARG PYTHON_VERSION and FROM reference the selected version
    - If no explicit COPY for src exists, it's okay to keep COPY . . since our folder is small.
    """
    lines = content.splitlines()
    out = []
    seen_arg = False
    from_idx = -1
    for i, line in enumerate(lines):
        # Normalize the gunicorn entrypoint
        if "gunicorn" in line and "app:app" in line:
            # normalize module path
            if "src.app:app" not in line:
                line = line.replace("app:app", "src.app:app")
            # normalize workers
            line = _replace_arg_in_json_cmd(line, "-w", str(workers))
            # normalize timeout
            line = _replace_arg_in_json_cmd(line, "--timeout", str(timeout))
            # normalize bind address to IPv6 any ([::])
            line = line.replace("0.0.0.0:8080", "[::]:8080")
        # Track FROM line index
        if line.strip().startswith("FROM "):
            from_idx = len(out)
        # Normalize ARG PYTHON_VERSION
        if line.strip().startswith("ARG PYTHON_VERSION="):
            line = f"ARG PYTHON_VERSION={python_version}"
            seen_arg = True
        # Keep the rest
        out.append(line)
    content = "\n".join(out)

    # Ensure ARG PYTHON_VERSION exists near top
    if not seen_arg:
        # Insert ARG after syntax line if present, else at top
        insert_pos = 1 if (lines and lines[0].startswith("# syntax=")) else 0
        parts = content.splitlines()
        parts.insert(insert_pos, f"ARG PYTHON_VERSION={python_version}")
        content = "\n".join(parts)

    # Ensure FROM uses ${PYTHON_VERSION}-slim
    parts = content.splitlines()
    for i, ln in enumerate(parts):
        if ln.strip().startswith("FROM ") and "python:" in ln:
            parts[i] = "FROM python:${PYTHON_VERSION}-slim"
            break
    content = "\n".join(parts)

    # Ensure EXPOSE 8080 exists (avoid duplicates)
    if "EXPOSE 8080" not in content:
        content += "\n\nEXPOSE 8080\n"
    
    # Strip any manual JSON copy directives; runtime reads data from local storage/S3.
    content = re.sub(
        r"\n?# Include manual department prefix overrides in the image\nCOPY storage/data/manualPrefixes.json storage/data/manualPrefixes.json",
        "",
        content,
    )
    content = content.replace(
        "COPY storage/data/manualPrefixes.json storage/data/manualPrefixes.json\n",
        "",
    )
    return content


def _replace_arg_in_json_cmd(line: str, flag: str, value: str) -> str:
    """Best-effort replace of a gunicorn CLI arg in a JSON-array CMD line.

    If flag exists, replace the token after it. If absent, append the pair before the
    final entry (typically the application module path).
    """
    match = re.search(r"CMD\s*(\[[^\]]*\])", line)
    if not match:
        return line

    cmd_text = match.group(1)
    try:
        cmd = json.loads(cmd_text)
    except json.JSONDecodeError:
        return line

    if not isinstance(cmd, list):
        return line

    flag = str(flag)
    value = str(value)

    try:
        idx = cmd.index(flag)
    except ValueError:
        insertion_index = max(len(cmd) - 1, 0)
        cmd.insert(insertion_index, flag)
        cmd.insert(insertion_index + 1, value)
    else:
        if idx + 1 < len(cmd):
            cmd[idx + 1] = value
        else:
            cmd.append(value)

    new_cmd_text = json.dumps(cmd)
    return f"{line[:match.start(1)]}{new_cmd_text}{line[match.end(1):]}"


def patch_fly_toml(content: str, app_name: str, region: str) -> str:
    """Patch fly.toml to set app name, region, ensure internal port 8080, add [env] defaults and /status check."""
    lines = content.splitlines()
    out = []
    for line in lines:
        if line.strip().startswith("app = "):
            line = f"app = '{app_name}'"
        elif line.strip().startswith("primary_region = "):
            line = f"primary_region = '{region}'"
        elif "internal_port" in line:
            # Force 8080
            line = "  internal_port = 8080"
        out.append(line)
    content = "\n".join(out)
    # If http_service block missing, append a minimal block
    if "[http_service]" not in content:
        content += (
            "\n[http_service]\n  internal_port = 8080\n  force_https = true\n"
            "  auto_stop_machines = 'off'\n  auto_start_machines = false\n  min_machines_running = 1\n"
            "  processes = ['app']\n"
        )
    # Ensure [env] block with defaults exists
    if "\n[env]\n" not in content:
        content += (
            "\n[env]\n  LOG_LEVEL = \"INFO\"\n  LOG_JSON = \"false\"\n  APP_VERSION = \"0.1.0\"\n  ALLOWED_ORIGINS = \"*\"\n"
        )
    # Ensure an HTTP /status check exists; try adding under [http_service]
    if "/status" not in content and "http_service" in content:
        content = content.replace(
            "[http_service]",
            (
                "[http_service]\n  [[http_service.checks]]\n    type = \"http\"\n    interval = \"10s\"\n"
                "    timeout = \"2s\"\n    grace_period = \"10s\"\n    method = \"get\"\n    path = \"/status\"\n"
            ),
            1,
        )
    return content


def make_deploy(
    repo_root: Path,
    app_name: str,
    region: str,
    python_version: str,
    target: Path,
    force: bool,
    from_templates: Path | None,
    workers: int,
    timeout: int,
) -> Path:
    backend_dir = repo_root / "backend"
    if not backend_dir.exists():
        raise RuntimeError(f"Could not locate backend dir at {backend_dir}")

    if target.exists() and force:
        shutil.rmtree(target)
    target.mkdir(parents=True, exist_ok=True)

    # Copy essentials
    copy_requirements(backend_dir, target)
    copy_sources(backend_dir, target)

    # Infra files: either import from --from-templates or generate
    dockerfile_path = target / "Dockerfile"
    fly_toml_path = target / "fly.toml"

    if from_templates:
        src_docker = from_templates / "Dockerfile"
        src_fly = from_templates / "fly.toml"
        if src_docker.exists():
            content = read_file_text(src_docker)
            content = patch_dockerfile(
                content, python_version=python_version, workers=workers, timeout=timeout
            )
            write_file(dockerfile_path, content)
        else:
            write_file(
                dockerfile_path,
                DOCKERFILE_TEMPLATE.format(
                    python_version=python_version, workers=workers, timeout=timeout
                ),
            )
        if src_fly.exists():
            content = read_file_text(src_fly)
            content = patch_fly_toml(content, app_name=app_name, region=region)
            write_file(fly_toml_path, content)
        else:
            write_file(
                fly_toml_path,
                FLY_TOML_TEMPLATE.format(app_name=app_name, region=region),
            )
    else:
        write_file(
            dockerfile_path,
            DOCKERFILE_TEMPLATE.format(
                python_version=python_version, workers=workers, timeout=timeout
            ),
        )
        write_file(
            fly_toml_path,
            FLY_TOML_TEMPLATE.format(app_name=app_name, region=region),
        )
    write_file(target / ".dockerignore", DOCKERIGNORE)

    # Small README to remind how to deploy
    readme = f"""# Fly.io deploy folder

This folder was generated by `backend/scripts/make_fly_deploy.py`.

Quickstart:
1) Authenticate: fly auth login
2) (First time) Create app: fly apps create {app_name}
3) (Optional) Set secrets: fly secrets set ACCESS_KEY=... SECRET_ACCESS_KEY=... MAIL_USERNAME=... MAIL_PASSWORD=...
4) Deploy: fly deploy

Service listens on 8080 and serves Flask app `src.app:app` via Gunicorn.
"""
    write_file(target / "README.md", readme)

    return target


def parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build a Fly.io deployable folder for backend")
    parser.add_argument(
        "--target",
        default=None,
        help="Output folder for the deploy package (default: <repo>/fly-io/robotdegilim)",
    )
    parser.add_argument(
        "--app-name",
        default=os.environ.get("FLY_APP_NAME", "robotdegilim-xyz"),
        help="Fly app name to write in fly.toml",
    )
    parser.add_argument(
        "--region",
        default=os.environ.get("FLY_REGION", "otp"),
        help="Primary region code (e.g., otp)",
    )
    parser.add_argument(
        "--python-version",
        default=os.environ.get("PYTHON_VERSION", RECOMMENDED_PY_VERSION),
        help="Python version for the Docker image (e.g., 3.10.9)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Delete target dir if it already exists",
    )
    parser.add_argument(
        "--from-templates",
        default=None,
        help="Path containing Dockerfile and fly.toml from a previous deploy (they will be patched)",
    )
    parser.add_argument(
        "--gunicorn-workers",
        type=int,
        default=int(os.environ.get("GUNICORN_WORKERS", "2")),
        help="Gunicorn worker processes (default 2)",
    )
    parser.add_argument(
        "--gunicorn-timeout",
        type=int,
        default=int(os.environ.get("GUNICORN_TIMEOUT", "0")),
        help="Gunicorn timeout seconds (0 means no timeout; default 0)",
    )
    return parser.parse_args(argv)


def main(argv: list[str]) -> int:
    args = parse_args(argv)

    # Resolve repo root as two levels up from this script: backend/scripts -> repo_root
    script_path = Path(__file__).resolve()
    repo_root = script_path.parents[2]

    default_target = repo_root / "fly-io" / "robotdegilim"
    target = Path(args.target).resolve() if args.target else default_target

    from_templates = Path(args.from_templates).resolve() if args.from_templates else None

    built = make_deploy(
        repo_root=repo_root,
        app_name=args.app_name,
        region=args.region,
        python_version=args.python_version,
        target=target,
        force=args.force,
        from_templates=from_templates,
        workers=args.gunicorn_workers,
        timeout=args.gunicorn_timeout,
    )

    rel = os.path.relpath(built, repo_root)
    print(f"Fly deploy folder created: {built} (repo-relative: {rel})")
    print("Next steps:")
    print(f"  1) cd {built}")
    print("  2) fly auth login (if needed)")
    print(f"  3) fly apps create {args.app_name} (first time)")
    print("  4) fly secrets set ACCESS_KEY=... SECRET_ACCESS_KEY=... MAIL_USERNAME=... MAIL_PASSWORD=...")
    print("  5) fly deploy")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
